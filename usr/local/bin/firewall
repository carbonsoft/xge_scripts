#!/bin/bash

. /cfg/config
. /usr/local/lib/carbon_firewall_lib

app=${app['appname']}

config=/var/lib/users.dat
usersd=/usr/local/sbin/firewall_usersd
qos=/usr/local/bin/shaper.sh

xge_nat() {
	NAT_DROP=" DNAT --to-dest 169.169.169.169"
	iptables -t nat -N xge_postrouting
	iptables -t nat -N xge_user2snat
	iptables -t nat -A xge_postrouting -j xge_user2snat

	# dnat
	iptables -t nat -N xge_dnat
	iptables -t nat -N xge_redirect
	iptables -t nat -N xge_redirect_noauth
	iptables -t nat -N xge_redirect_webauth

	# redirect
	iptables -t nat -A xge_redirect -p tcp -m addrtype --dst-type LOCAL -j RETURN
	iptables -t nat -A xge_redirect -p udp --dport 53 -j RETURN
	iptables -t nat -A xge_redirect -p tcp --dport 80 -j DNAT --to-dest ${network['if1.ip']%%/*}:${httpd['redirect_port']}
	iptables -t nat -A xge_redirect -j $NAT_DROP

	# noauth
	iptables -t nat -A xge_redirect_noauth -p tcp -m addrtype --dst-type LOCAL -j RETURN
	iptables -t nat -A xge_redirect_noauth -p udp --dport 53 -j RETURN
	iptables -t nat -A xge_redirect_noauth -p tcp --dport 80 -j DNAT --to-dest ${network['if1.ip']%%/*}:${httpd['redirect_noauth_port']}
	iptables -t nat -A xge_redirect_noauth -j $NAT_DROP

	# webauth
	iptables -t nat -A xge_redirect_webauth -p tcp -m addrtype --dst-type LOCAL -j RETURN
	iptables -t nat -A xge_redirect_webauth -p udp --dport 53 -j RETURN
	iptables -t nat -A xge_redirect_webauth -p tcp --dport 80 -j DNAT --to-dest ${network['if1.ip']%%/*}:${httpd['redirect_webauth_port']}
	iptables -t nat -A xge_redirect_webauth -j $NAT_DROP

	# links in xge_dnat
	iptables -t nat -A xge_dnat -m set --set xge_redirect src  -j xge_redirect
	iptables -t nat -A xge_dnat -m set --set xge_redirect_noauth src -j xge_redirect_noauth
	iptables -t nat -A xge_dnat -m set --set xge_redirect_webauth src -j xge_redirect_webauth

	# final link
	iptables -t nat -A PREROUTING -j xge_dnat
	iptables -t nat -A POSTROUTING -j xge_postrouting

	iptables_file=/tmp/iptables_file.nat.$$
	echo "#" > $iptables_file
	make_tree nat user2snat user2snat s
	if ! iptables-restore --noflush < $iptables_file; then
		cat $iptables_file
		exit 1
	fi
}

# стандартные ipset'ы разрешить/запретить инет
xge_ipset() {
	ipset create xge_forward_allow hash:ip family inet hashsize 65536 maxelem 65536
	ipset create xge_forward_deny hash:ip family inet hashsize 65536 maxelem 65536
	ipset create xge_mangle_accept hash:ip family inet hashsize 65536 maxelem 65536
	ipset create xge_nat_default hash:ip family inet hashsize 65536 maxelem 65536
	ipset create xge_redirect hash:ip family inet hashsize 65536 maxelem 65536
	ipset create xge_redirect_noauth hash:ip family inet hashsize 65536 maxelem 65536
	ipset create xge_redirect_webauth hash:ip family inet hashsize 65536 maxelem 65536
}

xge_filter() {
	# цепочка для ULOG для nfusens
	iptables -t filter -N xge_forward
	iptables -t filter -A FORWARD -j xge_forward
	iptables -t filter -N xge_ULOGd
	iptables -t filter -A xge_ULOGd -j ULOG --ulog-nlgroup 1 --ulog-qthreshold 50 --ulog-cprange 24
	iptables -t filter -A xge_forward -d 169.169.169.169 -j REJECT --reject-with icmp-admin-prohibited
	iptables -t filter -A xge_forward -m set --set xge_forward_allow src -j xge_ULOGd
	iptables -t filter -A xge_forward -m set --set xge_forward_allow dst -j xge_ULOGd
	iptables -t filter -A xge_forward -m set --set xge_forward_allow src -j ACCEPT
	iptables -t filter -A xge_forward -m set --set xge_forward_allow dst -j ACCEPT

	# принимает уже установленные соединения
	iptables -t filter -A xge_forward -m state --state ESTABLISHED -j ACCEPT
	iptables -t filter -A xge_forward -j DROP

	# получение команд от биллинга
	iptables -t filter -N xge_in_accept
	iptables -t filter -A xge_in_accept -s ${radclient['authserver']##*:} -p udp --dport 44 -j ACCEPT

	# pptp
	iptables -t filter -A xge_in_accept -p tcp --dport 1723 -j ACCEPT
	iptables -t filter -A xge_in_accept -p 47 -j ACCEPT

	# radius coa, TODO fix range
	if [ -n "${radclient['coa_client.ip']}" -a -n "${radclient['coa_server.port']}" ]; then
		iptables -t filter -A xge_in_accept -s "${radclient['coa_client.ip']}" -p udp --dport "${radclient['coa_server.port']}" -j ACCEPT
	fi

	iptables -t filter -I INPUT -j xge_in_accept
}

create_connlimit() {
	if [ "${firewall['new_limit_l']}" != "" ]; then
		limit=$((${firewall['new_limit_l']}/8))
		iptables -t mangle -N xge_new_limit_l_tcp
		iptables -t mangle -F xge_new_limit_l_tcp
		iptables -t mangle -N xge_new_limit_l_udp
		iptables -t mangle -F xge_new_limit_l_udp
		iptables -t mangle -A xge_state_new ! -i E+ -p tcp --dport  1024: -j xge_new_limit_l_tcp
		iptables -t mangle -A xge_state_new ! -i E+ -p udp --dport  1024: -j xge_new_limit_l_udp
		iptables -t mangle -A xge_new_limit_l_tcp -p tcp  --dport 1723 -j RETURN
		iptables -t mangle -A xge_new_limit_l_tcp -p tcp  --dport 5190 -j RETURN

		for i in {0..7}; do
			iptables -t mangle -A xge_new_limit_l_tcp -p tcp -s 0.0.0.$i/0.0.0.7 -m limit --limit $limit/sec --limit-burst 5 -j RETURN
		done

		iptables -t mangle -A xge_new_limit_l_tcp -p tcp -m limit --limit 6/min -j LOG --log-level debug --log-prefix "NET_${new_limit_l}_TCP_DROP "
		iptables -t mangle -A xge_new_limit_l_tcp -j DROP

		for i in {0..7}; do
			iptables -t mangle -A xge_new_limit_l_udp -p udp -s 0.0.0.$i/0.0.0.7 -m limit --limit $limit/sec --limit-burst 5 -j RETURN
		done
		iptables -t mangle -A xge_new_limit_l_udp -p udp -m limit --limit 6/min -j LOG --log-level debug --log-prefix 'NET_${new_limit_l}_UDP_DROP '
		iptables -t mangle -A xge_new_limit_l_udp -j DROP
	fi

	if [ "${firewall['new_limit_e']}" != "" ]; then
		limit=$((${firewall['new_limit_e']}/8))
		iptables -t mangle -N xge_new_limit_e_tcp
		iptables -t mangle -F xge_new_limit_e_tcp
		iptables -t mangle -N xge_new_limit_e_udp
		iptables -t mangle -F xge_new_limit_e_udp
		iptables -t mangle -A xge_state_new ! -i E+ -p tcp --dport  1024: -j xge_new_limit_e_tcp
		iptables -t mangle -A xge_state_new ! -i E+ -p udp --dport  1024: -j xge_new_limit_e_udp
		iptables -t mangle -A xge_new_limit_e_tcp -p tcp  --dport 1723 -j RETURN
		iptables -t mangle -A xge_new_limit_e_tcp -p tcp  --dport 5190 -j RETURN

		for i in {0..7}; do
			iptables -t mangle -A xge_new_limit_e_tcp -p tcp -s 0.0.0.$i/0.0.0.7 -m limit --limit $limit/sec --limit-burst 5 -j RETURN
		done

		iptables -t mangle -A xge_new_limit_e_tcp -p tcp -m limit --limit 6/min -j LOG --log-level debug --log-prefix "NET_${new_limit_l}_TCP_DROP "
		iptables -t mangle -A xge_new_limit_e_tcp -j DROP

		for i in {0..7}; do
			iptables -t mangle -A xge_new_limit_e_udp -p udp -s 0.0.0.$i/0.0.0.7 -m limit --limit $limit/sec --limit-burst 5 -j RETURN
		done
		iptables -t mangle -A xge_new_limit_e_udp -p udp -m limit --limit 6/min -j LOG --log-level debug --log-prefix 'NET_${new_limit_l}_UDP_DROP '
		iptables -t mangle -A xge_new_limit_e_udp -j DROP
	fi
}

xge_mangle() {
	# создадим xge_state_new, туда пойдут все новые соединения
	iptables -t mangle -N xge_prerouting
	iptables -t mangle -A PREROUTING -j xge_prerouting
	iptables -t mangle -N xge_postrouting
	iptables -t mangle -A POSTROUTING -j xge_postrouting
	iptables -t mangle -N xge_state_new
	iptables -t mangle -A xge_prerouting -m set --set xge_mangle_accept src -j ACCEPT
	iptables -t mangle -A xge_prerouting -m state --state NEW -j xge_state_new
	create_connlimit

	# маркируем соединения и шлём в шейперы
	iptables -t mangle -A xge_prerouting -j MARK --src-save
	iptables -t mangle -A xge_prerouting -j IMQ --todev 0
	iptables -t mangle -A xge_postrouting -j MARK --dst-save
	iptables -t mangle -A xge_postrouting -j IMQ --todev 1

}

start() {
	$qos
	xge_ipset
	xge_nat
	xge_filter
	xge_mangle
	$usersd start
}

stop() {
	iptables_cleanup
	ipset_cleanup
}

restart() {
	stop
	start
}

$1
