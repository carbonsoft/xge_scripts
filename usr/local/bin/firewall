#!/bin/bash

# Design notes:
# 1. Все правила разбиты по функциям одноимённым с таблицей в которую добавляются
# 2. Все правила стоит писать в одну строчку чтобы разработчики могли спокойно грепать их
# 3. Стоит избегать использования переменных в правилах во славу удобного поиска и копирования-вставки для отладки руками

export PATH=$PATH:/usr/local/bin/
trap _exit EXIT

_exit() {
	local ret=$?
	rm -f /tmp/firewall/*.$$
	return $ret
}

. /cfg/config
app=${app['appname']}
. /usr/local/lib/carbon_firewall_lib


config=/var/lib/users.dat
usersd=/usr/local/sbin/firewall_usersd
shaper=/usr/local/bin/shaper.sh


ip_regex='([0-9]{1,3}\.){3}[0-9]{1,3}'

xge_nat() {
	iptables -t nat -N xge_pre
	iptables -t nat -N xge_post
	iptables -t nat -N xge_user2snat

	# dnat
	iptables -t nat -A xge_pre -s "${firewall['billing_ip']}" -j ACCEPT
	iptables -t nat -A xge_pre -d "${firewall['billing_ip']}" -j ACCEPT

	# noauth
	if [ "${httpd['redirect_webauth.enabled']}" -eq "1" ]; then
		iptables -t nat -A xge_pre -p tcp --dport 80 -m addrtype ! --dst-type LOCAL -m set ! --set xge_auth_list src -m set ! --set xge_auth_list dst -j DNAT --to-dest "${httpd['internal_ip']}":446
	else
		iptables -t nat -A xge_pre -p tcp --dport 80 -m addrtype ! --dst-type LOCAL -m set ! --set xge_auth_list src -m set ! --set xge_auth_list dst -j DNAT --to-dest "${httpd['internal_ip']}":440
	fi

	iptables -t nat -A xge_pre -p tcp --dport 80 -m addrtype ! --dst-type LOCAL -m set --set xge_trust_blocked_list dst -j ACCEPT
	# blocked
	iptables -t nat -A xge_pre -p tcp --dport 80 -m addrtype ! --dst-type LOCAL -m set --set xge_blocked_list src -j DNAT --to-dest "${httpd['internal_ip']}":444

	# negbal
	iptables -t nat -A xge_pre -p tcp --dport 80 -m addrtype ! --dst-type LOCAL -m set --set xge_negbal_list src -m set ! --set xge_trust_negbal_list dst -j DNAT --to-dest "${httpd['internal_ip']}":442

	# snat
	iptables_file=/tmp/firewall/iptables_file.nat.$$
	echo "#" > $iptables_file
	make_tree nat user2snat user2snat s >> $iptables_file
	if ! iptables-restore --noflush < $iptables_file; then
		cat $iptables_file
		exit 1
	fi
	iptables -t nat -A xge_post -j xge_user2snat

	if [ "${app['default_snat_enabled']}" = '1' ]; then
		iptables -t nat -A xge_post -m addrtype ! --dst-type LOCAL -m set --set xge_local_net src -m set ! --set xge_local_net dst -j MASQUERADE
	fi

	# final link
	iptables -t nat -A PREROUTING -j xge_pre
	iptables -t nat -A POSTROUTING -j xge_post
}

# стандартные ipset'ы разрешить/запретить инет
xge_ipset() {
	ipset create xge_auth_list hash:ip family inet hashsize 65536 maxelem 65536
	ipset create xge_negbal_list hash:ip family inet hashsize 65536 maxelem 65536
	ipset create xge_blocked_list hash:ip family inet hashsize 65536 maxelem 65536
	ipset create xge_local_net hash:net family inet hashsize 65536 maxelem 65536
	ipset create xge_trust_blocked_list hash:net family inet hashsize 65536 maxelem 65536
	ipset create xge_trust_negbal_list hash:net family inet hashsize 65536 maxelem 65536
}

# load ip from configs
xge_ipset_load() {
	ipset flush xge_trust_blocked_list
	for net in ${networks['trust_blocked_list']}; do
		ipset add xge_trust_blocked_list $net
	done

	ipset flush xge_trust_negbal_list
	#При использовании без 5биллинга
	for net in ${networks['trust_negbal_list']}; do
		ipset add xge_trust_negbal_list $net
	done

	ipset flush xge_local_net
	[ -z "${networks['local_net']:-}" ] && networks['local_net']="192.168.0.0/16 172.16.0.0/12 10.0.0.0/8"
	for net in ${networks['local_net']}; do
		ipset add xge_local_net $net
	done
}

xge_filter() {
	# цепочка для ULOG для nfusens
	iptables -t filter -N xge_forward
	iptables -t filter -A FORWARD -j xge_forward
	iptables -t filter -N xge_ULOGd
	iptables -t filter -A xge_ULOGd -j ULOG --ulog-nlgroup 1 --ulog-qthreshold 50 --ulog-cprange 24
	iptables -t filter -A xge_forward -j xge_ULOGd
	# оптимизация бэкпорт из 4 iptables -t filter -A xge_forward -m conmark2=1 -m каждый не тысячный пакет -m не реже раз в 5 мин -m state --state ESTABLISHED -j ACCEPT
	iptables -t filter -A xge_forward -d ${firewall['billing_ip']} -j ACCEPT
	iptables -t filter -A xge_forward -s ${firewall['billing_ip']} -j ACCEPT
	iptables -t filter -A xge_forward -p udp --dport 53 -j ACCEPT
	iptables -t filter -A xge_forward -p udp --sport 53 -m state --state ESTABLISHED -j ACCEPT

	# Все, что не auth_list дропаем
	iptables -t filter -A xge_forward -m set ! --set xge_auth_list src -m set ! --set xge_auth_list dst -j DROP

	iptables -t filter -A xge_forward -m set --set xge_trust_blocked_list dst -m set --set xge_auth_list src -j ACCEPT
	iptables -t filter -A xge_forward -m set --set xge_trust_blocked_list src  -m set --set xge_auth_list dst -j ACCEPT

	# redirect_blocked drop
	iptables -t filter -A xge_forward -m set --set xge_blocked_list dst -j DROP
	iptables -t filter -A xge_forward -m set --set xge_blocked_list src -j DROP

	iptables -t filter -A xge_forward -m set --set xge_trust_negbal_list src -m set --set xge_auth_list dst -j ACCEPT
	iptables -t filter -A xge_forward -m set --set xge_trust_negbal_list dst -m set --set xge_auth_list src -j ACCEPT
	# redirect_negbal drop
	iptables -t filter -A xge_forward -m set --set xge_negbal_list dst -j DROP
	iptables -t filter -A xge_forward -m set --set xge_negbal_list src -j DROP

	# Сюда попадут только авторизованные
	iptables -t filter -A xge_forward -j ACCEPT

	####################################### INPUT ###########################
	#
	# pptp
	iptables -t filter -N xge_input
	iptables -t filter -A xge_input -m state --state ESTABLISHED -j ACCEPT
	iptables -t filter -A xge_input -p tcp --dport 1723 -m set --set xge_local_net src -j ACCEPT
	iptables -t filter -A xge_input -p 47 -m set --set xge_local_net src -j ACCEPT

	# l2tp
	iptables -t filter -A xge_input -p udp --dport 1701 -m set --set xge_local_net src -j ACCEPT

	# dns
	iptables -t filter -A xge_input -p udp --dport 53 -j ACCEPT
	iptables -t filter -A xge_input -p tcp --dport 53 -j ACCEPT

	# локальный вебсервер редиректов и авторизации
	iptables -t filter -A xge_input -d "${httpd['internal_ip']}" -j ACCEPT

	# radius coa, TODO fix range
	if [ -n "${radclient['coa_client.ip']}" -a -n "${radclient['coa_server.port']}" ]; then
		iptables -t filter -A xge_input -s "${radclient['coa_client.ip']}" -p udp --dport "${radclient['coa_server.port']}" -j ACCEPT
		# in billing_softrouter we have routing issue, if we have 169.1.37.99 on dummy
		# we gonna connect to it with same src - 169.1.37.99
		# so accept nas_identifier ip so as src, so as dst
		# for sys_app in $(get_app_list); do
		# 	if [ "$sys_app" = 'asr_billing' ]; then
		iptables -t filter -A xge_input -i lo -d "${radclient['nas_identifier']}" -p udp --sport "${radclient['coa_server.port']}" -j ACCEPT
		iptables -t filter -A xge_input -i lo -s "${radclient['nas_identifier']}" -p udp --dport "${radclient['coa_server.port']}" -j ACCEPT
		# 		break
		# 	fi
		# done
	fi


	# BGP
	iptables -t filter -A xge_input -p tcp --dport 179 -j ACCEPT
	iptables -t filter -A xge_input -p tcp --sport 179 -m state --state ESTABLISHED -j ACCEPT

	iptables -t filter -A xge_input -p udp --dport 179 -j ACCEPT
	iptables -t filter -A xge_input -p udp --sport 179 -m state --state ESTABLISHED -j ACCEPT

	# OSPF
	iptables -t filter -A xge_input -p 89 -j ACCEPT

	# RIP
	iptables -t filter -A xge_input -p udp --dport 520:521 -j ACCEPT
	iptables -t filter -A xge_input -p udp --sport 520:521 -m state --state ESTABLISHED -j ACCEPT
	# Баг старой зебры в новой не подтвержден iptables -t nat -A POSTROUTING -p udp --dport 520 -j SNAT --to-source :520

	# quagga telnet
	iptables -t filter -A xge_input -p tcp --dport 2600:2605 -j ACCEPT
	iptables -t filter -I INPUT -j xge_input

	####################################### OUTPUT ###########################
	#
	iptables -t filter -N xge_output
	iptables -t filter -I OUTPUT -j xge_output


}

create_new_pkt_limit() {
	if [ "${firewall['new_limit_l']}" != "" ]; then
		limit=$((${firewall['new_limit_l']}/8))
		iptables -t mangle -N xge_new_limit_l_tcp
		iptables -t mangle -F xge_new_limit_l_tcp
		iptables -t mangle -N xge_new_limit_l_udp
		iptables -t mangle -F xge_new_limit_l_udp
		iptables -t mangle -A xge_state_new -p tcp --dport  1024: -m set --set xge_auth_list src -j xge_new_limit_l_tcp
		iptables -t mangle -A xge_state_new -p udp --dport  1024: -m set --set xge_auth_list src -j xge_new_limit_l_udp
		iptables -t mangle -A xge_new_limit_l_tcp -p tcp  --dport 1723 -j RETURN
		iptables -t mangle -A xge_new_limit_l_tcp -p tcp  --dport 5190 -j RETURN

		for i in {0..7}; do
			iptables -t mangle -A xge_new_limit_l_tcp -p tcp -s 0.0.0.$i/0.0.0.7 -m limit --limit $limit/sec --limit-burst 5 -j RETURN
		done

		iptables -t mangle -A xge_new_limit_l_tcp -p tcp -m limit --limit 6/min -j LOG --log-level debug --log-prefix "NET_${new_limit_l}_TCP_DROP "
		iptables -t mangle -A xge_new_limit_l_tcp -j DROP

		for i in {0..7}; do
			iptables -t mangle -A xge_new_limit_l_udp -p udp -s 0.0.0.$i/0.0.0.7 -m limit --limit $limit/sec --limit-burst 5 -j RETURN
		done
		iptables -t mangle -A xge_new_limit_l_udp -p udp -m limit --limit 6/min -j LOG --log-level debug --log-prefix 'NET_${new_limit_l}_UDP_DROP '
		iptables -t mangle -A xge_new_limit_l_udp -j DROP
	fi

	if [ "${firewall['new_limit_e']}" != "" ]; then
		limit=$((${firewall['new_limit_e']}/8))
		iptables -t mangle -N xge_new_limit_e_tcp
		iptables -t mangle -F xge_new_limit_e_tcp
		iptables -t mangle -N xge_new_limit_e_udp
		iptables -t mangle -F xge_new_limit_e_udp
		iptables -t mangle -A xge_state_new -p tcp --dport  1024: -m set --set xge_auth_list src -j xge_new_limit_e_tcp
		iptables -t mangle -A xge_state_new -p udp --dport  1024: -m set --set xge_auth_list src -j xge_new_limit_e_udp
		iptables -t mangle -A xge_new_limit_e_tcp -p tcp  --dport 1723 -j RETURN
		iptables -t mangle -A xge_new_limit_e_tcp -p tcp  --dport 5190 -j RETURN

		for i in {0..7}; do
			iptables -t mangle -A xge_new_limit_e_tcp -p tcp -s 0.0.0.$i/0.0.0.7 -m limit --limit $limit/sec --limit-burst 5 -j RETURN
		done

		iptables -t mangle -A xge_new_limit_e_tcp -p tcp -m limit --limit 6/min -j LOG --log-level debug --log-prefix "NET_${new_limit_l}_TCP_DROP "
		iptables -t mangle -A xge_new_limit_e_tcp -j DROP

		for i in {0..7}; do
			iptables -t mangle -A xge_new_limit_e_udp -p udp -s 0.0.0.$i/0.0.0.7 -m limit --limit $limit/sec --limit-burst 5 -j RETURN
		done
		iptables -t mangle -A xge_new_limit_e_udp -p udp -m limit --limit 6/min -j LOG --log-level debug --log-prefix 'NET_${new_limit_l}_UDP_DROP '
		iptables -t mangle -A xge_new_limit_e_udp -j DROP
	fi
}

xge_mangle() {
	# создадим xge_state_new, туда пойдут все новые соединения
	iptables -t mangle -N xge_pre
	iptables -t mangle -A PREROUTING -j xge_pre
	iptables -t mangle -N xge_post
	iptables -t mangle -A POSTROUTING -j xge_post
	iptables -t mangle -N xge_state_new
	#iptables -t mangle -A xge_pre -m set --set xge_mangle_accept src -j ACCEPT
	iptables -t mangle -A xge_pre -m state --state NEW -j xge_state_new
	create_new_pkt_limit
	# TODO create_conlimit бэкпортироввать из 4 или написать с 0 добавив new_pkt_limit_per_sec_per_usr

	# маркируем соединения и шлём в шейперы
	iptables -t mangle -A xge_pre -j MARK --src-save
	iptables -t mangle -A xge_pre -j IMQ --todev 0

	# ZEBRA
	iptables -t mangle -I xge_pre -d 224.0.0.9/32 -p udp --dport 520 -m addrtype --dst-type LOCAL -j ACCEPT

	iptables -t mangle -A xge_post -j MARK --dst-save
	iptables -t mangle -A xge_post -j IMQ --todev 1

}

start() {
	firewall_clear
	set_proc_values.sh
	xge_ipset
	xge_nat
	xge_filter
	xge_mangle
	restore
	xge_ipset_load
}

stop() {
	save
}

restart() {
	stop
	start
}

$1
