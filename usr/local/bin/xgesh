#!/bin/bash

export PATH="$PATH:/usr/sbin/:/sbin/:/usr/local/sbin/"

#set >/tmp/1.log
#set -eux
#TODO: flock
#TODO: transparent ipset
#TODO: transparent iptables
#TODO: transparent tc
#TODO: transparent ip
#TODO: ip username snat policy lists mac class_id to some list or variable or magic to avoid dupicity
#TODO: trap EXIT _exit
#TODO: rotate class id [ ! -f $FILE_CLASS_ID ] && class_id=2000
# _exit()

# examples
#ip xge_forward add 192.168.1.1
#ip xge_snat add 192.168.1.1 2.2.2.2
#ip xge_redirect add 192.168.1.1
#ip mark88 add 192.168.1.1
#filter create fw_999 src-list drop
#filter create fw_999 src-list drop
#nat create fw_999 src-list snat
#nat create fw_999 src-list redirect
#policy set 192.168.1.1 in 10000 20000 12000 out 10000 20000 12000
# ip_access_list <ipset_command> <access_list_name> <accept|allow|deny|snat|dnat> <source> <destination> <ipset_name>

TAB_FILE="/var/lib/nas_iptab_nat.dat"
FILE_CLASS_ID=/var/lib/xge_class_id.tc
session_dir="/var/lib/xge_sessions/"
shapers_dir="/var/lib/xge_shapers"
free_shapers_dir="$shapers_dir/free"
lock_shapers_dir="$shapers_dir/lock"

lists_prepare() {
	for f in {2001..8998}; do
		touch $free_shapers_dir/$f
	done
}

prepare() {
	for dir in $session_dir $free_shapers_dir $lock_shapers_dir; do
		[ ! -d $dir ] && mkdir -p $dir
	done
}

die() {
	err="$1"
	shift
	echo "$@"
	exit $err
}

__session_update() {
	session_id="$1"
	shift
	var="$1"
	shift
	val="$@"
	_n=$'\n'
	_t=$'\t'
	val="${val//[-]/_}"
	val="${val//[$_n|$_t| ]/|}"
	[ "$val" = "" ] && val='-'
	row="- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
	[ -s $session_dir/$session_id ] && read row < $session_dir/$session_id
	read ip username snat policy lists mac class_id tmp <<< "$row"
	ip=$session_id #hack
	[ "$username" = '-' ] && username="S$ip"
	eval $var='$val'
	[ ! -d $session_dir ] && mkdir -p $session_dir
	echo $ip $username $snat $policy $lists $mac $class_id $tmp > $session_dir/$session_id.new
	[ "$?" = '0' ] && mv -f $session_dir/$session_id.new $session_dir/$session_id
}

__session_remove() {
	#TODO: убивать всё нах (if-down / radius-coa disconnect iptables/ipset)
	rm -f /var/lib/$session_dir/$ip
}

# __session_var_get session_id var
__session_var_get() {
	session_id="$1"
	shift
	var="$1"
	shift
	[ ! -s $session_dir/$session_id ] && return 1
	read ip username snat policy lists mac class_id tmp < $session_dir/$session_id
	local val=${!var}
	[ "$val" = '-' ] && val=''
	echo "$val"
}

# class_id_allocate $ip
class_id_allocate() {
	local ip="$1"
	local class_id=$(ls -1 $free_shapers_dir | head -1)
	if [ -z "$class_id" ]; then
		if [ -z "$(ls -1 $lock_shapers_dir)" ]; then
			lists_prepare
			class_id=$(ls -1 $free_shapers_dir | head -1)
		else
			echo "Error: No free class_id left" >&2
			return 1
		fi
	fi
	mv -f $free_shapers_dir/$class_id $lock_shapers_dir/$class_id || return 1
	echo $ip > $lock_shapers_dir/$class_id
	echo $class_id
}

# class_id_free $class_id
class_id_free() {
	local class_id="$1"
	mv -f $lock_shapers_dir/$class_id $free_shapers_dir/$class_id || return 1
	: > $free_shapers_dir/$class_id || return 1
}

tc() {
	/sbin/tc $@ || echo /sbin/tc $@
}

#ip2mark $ip
ip2mark() {
	[ "$#" = '0' ] && return 1
	local ip=( ${1//./ } )
	echo $((${ip[3]}*256*256*256+${ip[2]}*256*256+${ip[1]}*256+${ip[0]}))
}

# __shaper_add session_id rate_in ceil_in burst_in rate_out ceil_out burst_out

__try() {
	$@ || ((retval++))
}

__shaper_add() {
	local session_id="$1"
	local rate_in="$2"
	local ceil_in="$3"
	local burst_in="$4"
	local rate_out="$5"
	local ceil_out="$6"
	local burst_out="$7"
	local class_id="$(__session_var_get $session_id class_id)"
	local ip=$session_id
	[ -z "$ip" ] && return 1
	local mark=$(ip2mark $ip)
	[ -z "$mark" ] && return 2

	[ "$rate_in" = '-1' -a "$rate_out" = '-1' ] && return 1
	if [ -z $class_id ]; then
		class_id="$(class_id_allocate $ip)"
	fi

	[ -f $free_shapers_dir/$class_id ] && mv $free_shapers_dir/$class_id $lock_shapers_dir/$class_id
	quantum_out=$(( $ceil_out*1000/80 ));
	[ "$quantum_out" -gt 200000 ] && quantum_out=200000
	[ "$quantum_out" -lt 1500   ] && quantum_out=1500

	quantum_in=$(( $ceil_in*1000/80 ));
	[ "$quantum_in" -gt 200000 ] && quantum_in=200000
	[ "$quantum_in" -lt 1500   ] && quantum_in=1500

	local retval=0
	__try tc filter replace dev imq0 parent 1: protocol ip prio 1 handle $mark fw classid 1:$class_id
	__try tc filter replace dev imq1 parent 1: protocol ip prio 1 handle $mark fw classid 1:$class_id
	__try tc class replace dev imq0 parent 1:1 classid 1:$class_id htb rate ${rate_out}kbit ceil ${ceil_out}kbit prio 2 quantum $quantum_out
	__try tc class replace dev imq1 parent 1:1 classid 1:$class_id htb rate ${rate_in}kbit  ceil ${ceil_in}kbit  prio 2 quantum $quantum_in
	__try tc qdisc replace dev imq0 parent 1:$class_id handle $class_id: pfifo
	__try tc qdisc replace dev imq1 parent 1:$class_id handle $class_id: pfifo

	if [ "$retval" -gt '0' ]; then
		class_id_free $class_id
		return $retval
	fi

	__session_update $session_id class_id $class_id

	return $retval
}

# __shaper_del $session_id
__shaper_del() {
	local session_id="$1"
	local ip=$session_id
	[ -z "$ip" ] && return 1
	local mark=$(ip2mark $ip)
	[ -z "$mark" ] && return 2
	local class_id="$(__session_var_get $session_id class_id)"
	if [ -z "$class_id" ]; then
		echo "Error: class_id for $session_id not found"
		return 1
	fi
	local retval=0
	for dev in imq0 imq1; do
		__try tc filter del dev "$dev" parent "1:" prio 1 handle "$mark" fw
		__try tc qdisc  del dev "$dev" parent "1:$class_id"
		__try tc class  del dev "$dev" classid "1:$class_id"
	done
	[ "$retval" != '0' ] && return $retval
	class_id_free $class_id && __session_update $session_id class_id ''
}
#REFACTORING END

nat_chain_eval() {
	for i in ${1//./ }; do
		x=$((num<<8))
		num=$((x|i))
	done
	(( a=num & 15 ))
	(( b=(num & 240) >> 4 ))
	echo "xge_user2snat_${a}_${b}"
}

iptab_file_refresh() {
	if [ ! -f "$TAB_FILE" ] || [ $(($(date +%s) - $(stat -c %Y "$TAB_FILE"))) -gt 5 ]; then
		iptables -t nat -nL --line | fgrep SNAT > $TAB_FILE
		grep "NAT" $TAB_FILE > $TAB_FILE.SNAT
	else
		echo SKIP $FUNCNAME
	fi
}

snat_tree_add() {
	snat_tree_del $1 $2 &>/dev/null
	iptables -t nat -I $(nat_chain_eval $1) -s $1 -j SNAT --to-source $2 && __session_update $1 snat $2
}

snat_tree_del() {
	iptab_file_refresh
	NAT_CHAIN=$(nat_chain_eval $1)
	iptables -t nat -D $NAT_CHAIN -s $1 -j SNAT --to-source $2 &>/dev/null
	while read OLD_NUMBER_SNAT t t t t t to t; do
		[ -z "$OLD_NUMBER_SNAT" ] && break
		iptables -t nat -D $NAT_CHAIN -s $1 -j SNAT --to-source ${to//to:/}
	done <<< "$(fgrep $1 $TAB_FILE.SNAT)"
	__session_update $1 snat ''
}

session() {
	session_info() {
		cat $session_dir/$1
	}

	session_cmd="$1"
	shift
	case "$session_cmd" in
	info )
		session_info $@
		;;
	* )
		echo "bad subcommand: $session_cmd $@"
		return 1
		;;
	esac
}

# 	__ipset $action $list $ip
__ipset() {
	if [ "$1" = 'add' ]; then
		if ipset -q test $2 $3; then
			echo " $3 already in $2 "
			return 0
		fi
	fi
	ipset $@ || return $?
	lists="$(ipset -o save -l | fgrep -w $3 | cut -d ' ' -f2 | xargs)"
	__session_update $3 lists $lists

}

mac_set() {
	__session_update "$1" mac "$2"
}

mac_remove() {
	__session_update "$1" mac ''
}

policy() {
	# policy_set 10.128.0.75 in 1000 2000 3000 out 1000 2000 3000
	policy_set() {
		echo $FUNCNAME $@
		local ip="$1"
		shift

		params="$@"
		in=${params##*in }
		in=${in%% out*}
		out=${params##*out }

		read rate_in ceil_in burst_in tmp_in <<< "$in"
		read rate_out ceil_out burst_out tmp_out <<< "$out"

		rate_in=${rate_in:-512}
		ceil_in=${ceil_in:-$rate_in}
		burst_in=${burst_in:-0}
		rate_out=${rate_out:-512}
		ceil_out=${ceil_out:-$rate_out}
		burst_out=${burst_out:-0}

		__shaper_add $ip $rate_in $ceil_in $burst_in $rate_out $ceil_out $burst_out
		[ "$?" = '0' ] && __session_update $ip policy "in $rate_in $ceil_in $burst_in out $rate_out $ceil_out $burst_out"
	}

	# policy_remove 10.128.0.75
	policy_remove() {
		echo $FUNCNAME $@
		local ip="$1"
		shift
		__shaper_del $ip || return $?
		[ "$?" = '0' ] && __session_update $ip policy ''
	}

	policy_cmd="$1"
	shift
	case $policy_cmd in
	set | remove )
		policy_$policy_cmd $@
		;;
	* )
		echo "bad subcommand: $policy_cmd $@"
		return 1
		;;
	esac
}

ip() {
	local list="$1"
	local action="$2"
	local ip="$3"
	echo "$FUNCNAME $@"
	[ "${list:0:4}" != "xge_" ] && list=xge_$list

	if  [ "$#" -ge '4' -a "$list" = 'xge_snat' ]; then
		snatip=$4
		snat_tree_del "$3" "$4"
		if [ "$action" = 'add' ]; then
			snat_tree_add "$3" "$4"
			return $?
		fi
	fi
	__ipset $action $list $ip
}

main() {
	prepare
	cmd=$1
	shift
	case $cmd in
	ip | filter | nat | mangle | session | policy )
		$cmd $@
		;;
	* )
		die 1 "Bad command $cmd $@"
		return 1
		;;
	esac
}

main $@
