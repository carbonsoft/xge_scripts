#!/bin/bash

export PATH="$PATH:/usr/sbin/:/sbin/:/usr/local/sbin/"

#set >/tmp/1.log
#set -eux
#TODO: flock
#TODO: transparent ipset
#TODO: transparent iptables
#TODO: transparent tc
#TODO: transparent ip
#TODO: trap EXIT _exit
# _exit()

# examples
#ip xge_forward add 192.168.1.1
#ip xge_snat add 192.168.1.1 2.2.2.2
#ip xge_redirect add 192.168.1.1
#ip mark88 add 192.168.1.1
#filter create fw_999 src-list drop
#filter create fw_999 src-list drop
#nat create fw_999 src-list snat
#nat create fw_999 src-list redirect
#policy set 192.168.1.1 in 10000 20000 12000 out 10000 20000 12000
# ip_access_list <ipset_command> <access_list_name> <accept|allow|deny|snat|dnat> <source> <destination> <ipset_name>

TAB_FILE="/var/lib/nas_iptab_nat.dat"
FILE_CLASS_ID=/var/lib/class_id

die() {
	err="$1"
	shift
	echo "$@"
	exit $err
}

update_session() {
	session_id="$1"
	shift
	var="$1"
	shift
	val="${@// /|}"
	row="- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
	[ -s /var/lib/xge_sessions/$session_id ] && read row < /var/lib/xge_sessions/$session_id
	read ip username snat policy redirect mac tmp <<< "$row"
	ip=$session_id #hack
	eval $var=$val
	[ ! -d /var/lib/xge_sessions ] && mkdir -p /var/lib/xge_sessions
	echo $ip $username $snat $policy $redirect $mac $ip > /var/lib/xge_sessions/$session_id.new
	[ "$?" = '0' ] && mv -f /var/lib/xge_sessions/$session_id.new /var/lib/xge_sessions/$session_id
}

remove_session() {
	#TODO: убивать всё нах (if-down / radius-coa disconnect iptables/ipset)
	rm -f /var/lib/xge_session/$ip
}

new_class_id() {
	[ ! -f $FILE_CLASS_ID ] && class_id=2000
	read class_id t < $FILE_CLASS_ID
	((class_id++))
	while cut -d ' ' -f5 $FILE_CLASS_ID | fgrep -qw -m1 $class_id; do
		((class_id++))
	done
	echo $class_id > $FILE_CLASS_ID
}

tc() {
	/sbin/tc $@ || echo /sbin/tc $@
}

shaper_add() {
	# soi: правило пропускалось если задана только исходящая скорость

	[ "$RATE_IN" = '-1' -a "$RATE_OUT" = '-1' ] && return 1
	old_ip=
	read old_ip T T T class_id T <<< "$(fgrep -w -m 1 $IP $SAVEFILE)"
	if [ -z $old_ip ]; then
		echo 'мы не нашли сессию'
		new_class_id
	fi
	#удаление
	#rate_in, rate_out, ceil_in, ceil_out

	quantum_out=$(( $CEIL_OUT*1000/80 ));
	[ "$quantum_out" -gt 200000 ] && quantum_out=200000
	[ "$quantum_out" -lt 1500   ] && quantum_out=1500

	quantum_in=$(( $CEIL_IN*1000/80 ));
	[ "$quantum_in" -gt 200000 ] && quantum_in=200000
	[ "$quantum_in" -lt 1500   ] && quantum_in=1500

	tc filter replace dev imq0 parent 1: protocol ip prio 1 handle $MARK fw classid 1:$class_id
	tc filter replace dev imq1 parent 1: protocol ip prio 1 handle $MARK fw classid 1:$class_id
	tc class replace dev imq0 parent 1:1 classid 1:$class_id htb rate ${RATE_OUT}kbit ceil ${CEIL_OUT}kbit prio 2 quantum $quantum_out
	tc class replace dev imq1 parent 1:1 classid 1:$class_id htb rate ${RATE_IN}kbit  ceil ${CEIL_IN}kbit  prio 2 quantum $quantum_in
	tc qdisc replace dev imq0 parent 1:$class_id handle $class_id: pfifo
	tc qdisc replace dev imq1 parent 1:$class_id handle $class_id: pfifo
}

shaper_del() {
	read old_ip t t t class_id t <<< "$(fgrep -w -m 1 $IP $SAVEFILE)"
	if [ -z $old_ip ]; then
		echo 'мы не нашли сессию'
		return 1
	fi
	for dev in imq0 imq1; do
		tc filter del dev "$dev" parent "1:" prio 1 handle "$MARK" fw
		tc qdisc  del dev "$dev"     parent "1:$class_id"
		tc class  del dev "$dev"    classid "1:$class_id"
	done
}

nat_chain_eval() {
	for i in ${1//./ }; do
		x=$((num<<8))
		num=$((x|i))
	done
	(( a=num & 15 ))
	(( b=(num & 240) >> 4 ))
	echo "xge_user2snat_${a}_${b}"
}

iptab_file_refresh() {
	if [ ! -f "$TAB_FILE" ] || [ $(($(date +%s) - $(stat -c %Y "$TAB_FILE"))) -gt 5 ]; then
		iptables -t nat -nL --line | fgrep SNAT > $TAB_FILE
		grep "NAT" $TAB_FILE > $TAB_FILE.SNAT
	else
		echo SKIP $FUNCNAME
	fi
}

snat_tree_add() {
	snat_tree_del $1 $2 &>/dev/null
	iptables -t nat -I $(nat_chain_eval $1) -s $1 -j SNAT --to-source $2 && update_session $1 snat $2
}

snat_tree_del() {
	iptab_file_refresh
	NAT_CHAIN=$(nat_chain_eval $1)
	iptables -t nat -D $NAT_CHAIN -s $1 -j SNAT --to-source $2 &>/dev/null
	while read OLD_NUMBER_SNAT t t t t t to t; do
		[ -z "$OLD_NUMBER_SNAT" ] && break
		iptables -t nat -D $NAT_CHAIN -s $1 -j SNAT --to-source ${to//to:/}
	done <<< "$(fgrep $1 $TAB_FILE.SNAT)"
	update_session $1 snat -
}

__ipset() {
	if [ "$1" = 'add' ]; then
		ipset -q test $2 $3 && echo " $3 already in $2 " || ipset $@
		return 0
	fi

	ipset $@
}

mac_set() {
	update_session "$1" mac "$2"
}

mac_remove() {
	update_session "$1" mac -
}

ip() {
	local list="$1"
	local action="$2"
	local ip="$3"

	echo $FUNCNAME $@
	[ "${list:0:4}" != "xge_" ] && list=xge_$list

	if  [ "$#" -ge '4' -a "$list" = 'xge_snat' ]; then
		snatip=$4
		snat_tree_del "$3" "$4"
		if [ "$action" = 'add' ]; then
			snat_tree_add "$3" "$4"
			return $?
		fi
	fi

	__ipset $action $list $ip
}

main() {
	cmd=$1
	shift
	case $cmd in
	ip | filter | nat | mangle )
		$cmd $@
		;;
	* )
		die 1 "Bad command $cmd $@"
		return 1
		;;
	esac
}

main $@
